######################################################
#  Compiler                                          #
######################################################
CC=gcc
OPENMP_C_FLAG=-fopenmp -g -O2

######################################################
#  OPARI & DUMMY LIBRARY                             #
######################################################
POMP_INC=-I/opt/opari2/include
POMPLIBDIR=/svn/libnina/src
POMPLIB=-L${POMPLIBDIR} -lnina -lcpufreq

BINDIR=/opt/opari2/bin
OPARI=$(BINDIR)/opari2
OPARI2_CONFIG=$(BINDIR)/opari2-config

# We need to make sure that we use the right versions
# of nm, awk and grep. opari2-config returns the right
# commands with the necessary options.
NM=`$(OPARI2_CONFIG) --nm`
AWK_SCRIPT=`$(OPARI2_CONFIG) --region-initialization`

all: c 

######################################################
#  C EXAMPLE                                         #
######################################################

c: strassen_c strassen_c_inst

# Build without instrumentation
strassen_c: strassen.c
	$(CC) $(OPENMP_C_FLAG) $? -o $@

# Linking step
strassen_c_inst: strassen_c.mod.o pompregions_c.o
	$(CC) $(OPENMP_C_FLAG) $? $(POMPLIB) -o $@

pompregions_c.o : pompregions_c.c
	$(CC)  $(POMP_INC) -c $? -o $@

# Use nm to find the initialization functions in the 
# object file of the instrumented user code. Then the 
# awk script generates these functions.
pompregions_c.c : strassen_c.mod.o
	$(NM) strassen_c.mod.o | $(AWK_SCRIPT) > pompregions_c.c

strassen_c.mod.o: strassen.mod.c
	$(CC) $(OPENMP_C_FLAG) $(POMP_INC) -c $? -o $@

strassen.mod.c: strassen.c
	$(OPARI) strassen.c

clean:
	rm -rf strassen_?
	rm -rf strassen_?_inst
	rm -rf strassen.mod.?
	rm -rf strassen.?.opari.inc
	rm -rf pompregions_?.c
	rm -rf *.o
